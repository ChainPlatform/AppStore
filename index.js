function isPromise(obj){return!!obj&&typeof obj.then==="function"}function safeParse(raw){if(raw==null)return null;if(typeof raw==="object")return raw;if(typeof raw==="string"){try{return JSON.parse(raw)}catch{return raw}}return raw}function debounce(fn,wait=300){let t=null;return(...args)=>{if(t)clearTimeout(t);t=setTimeout(()=>fn(...args),wait)}}let globalConfig={storage:null,log:false};function logPrint(...args){const log=globalConfig.log;if(!log)return;if(typeof log==="function")log(...args);else if(log===true)console.log(...args)}class SingleStore{constructor(namespace,options={}){this.namespace=namespace;this.state={data:null,hydrated:false};this._listeners=new Set;this._hydrationListeners=new Set;this._persistDebounced=debounce(()=>this._persistNow())}get initialized(){return this.state.hydrated}get value(){return this.state.data}async hydrate(){try{if(!globalConfig.storage?.get)throw new Error("Storage adapter not configured");const raw=await globalConfig.storage.get(this.namespace);const parsed=safeParse(raw);this.state={data:parsed??null,hydrated:true};for(const cb of this._hydrationListeners){try{cb(parsed)}catch(e){logPrint(`[${this.namespace}] hydration listener error`,e)}}this._hydrationListeners.clear();logPrint(`[${this.namespace}] hydrated`,parsed);return parsed}catch(e){logPrint(`[${this.namespace}] hydrate error`,e);this.state={...this.state,hydrated:true};return null}}async _persistNow(){try{if(!globalConfig.storage?.set)throw new Error("Storage adapter not configured");const json=JSON.stringify(this.state.data??null);const maybePromise=globalConfig.storage.set(this.namespace,json);if(isPromise(maybePromise))await maybePromise;logPrint(`[${this.namespace}] persisted`,this.state.data)}catch(e){logPrint(`[${this.namespace}] persist error`,e)}}subscribe(cb,opts={fireImmediately:false}){if(typeof cb!=="function")throw new Error("subscribe expects a function");this._listeners.add(cb);if(opts.fireImmediately&&this.state.data!=null){try{cb(this.state.data,null)}catch(e){logPrint(`[${this.namespace}] subscribe cb error`,e)}}return()=>this._listeners.delete(cb)}onHydrated(cb){if(typeof cb!=="function")throw new Error("onHydrated expects a function");if(this.initialized){setTimeout(()=>cb(this.state.data),0);return()=>{}}this._hydrationListeners.add(cb);return()=>this._hydrationListeners.delete(cb)}_notify(newVal,oldVal){for(const cb of this._listeners){try{cb(newVal,oldVal)}catch(e){logPrint(`[${this.namespace}] listener error`,e)}}}set(partial){const prev=this.state.data;const next={...prev||{},...partial||{}};this.state={...this.state,data:next};this._notify(next,prev);this._persistDebounced()}replace(data){const prev=this.state.data;this.state={...this.state,data:data};this._notify(data,prev);this._persistDebounced()}clear(){this.replace(null)}async clearStorage(){try{if(!globalConfig.storage?.remove)throw new Error("Storage adapter not configured");const res=globalConfig.storage.remove(this.namespace);if(isPromise(res))await res}catch(e){logPrint(`[${this.namespace}] clearStorage error`,e)}this.clear()}}class AppStoreRoot{constructor(){this._stores=new Map}configure(config={}){if(config.storage)globalConfig.storage=config.storage;if(config.log!==undefined)globalConfig.log=config.log;logPrint("[AppStore] configured",config)}use(namespace,options){if(!namespace||typeof namespace!=="string")throw new Error("AppStore.use(namespace) requires a string");if(!this._stores.has(namespace)){this._stores.set(namespace,new SingleStore(namespace,options))}return this._stores.get(namespace)}async hydrateAll(){const hydrations=[];for(const store of this._stores.values()){hydrations.push(store.hydrate())}await Promise.all(hydrations)}clearAll(){for(const store of this._stores.values()){store.clear()}}}const AppStore=new AppStoreRoot;export default AppStore;